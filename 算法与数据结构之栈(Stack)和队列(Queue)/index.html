<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1,user-scalable=no"><meta name="renderer" content="webkit"><meta name="color-scheme" content="dark light"><meta name="author" content="Rick Lee"><meta name="description" content="思绪里的光影"><meta name="keywords" content="算法, 栈, 队列, Queue, Stack"><meta name="google-site-verification" content="pT025miUedSE-AHqhPkj7E9r3us5ch_qQHUFnDwly4w"><title>算法与数据结构之栈(Stack)和队列(Queue)</title><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="//at.alicdn.com/t/font_3242539_utq6ykfq7z.css"><link rel="stylesheet" light-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/github.min.css" dark-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/github-dark.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif" as="font"><link href="/style/index.css" rel="stylesheet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="独语" type="application/atom+xml">
</head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XCEJ392VGJ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag() {
  dataLayer.push(arguments);
}
gtag('js', new Date());
gtag('config', 'G-XCEJ392VGJ');</script><body><header class="page-header"><nav><ul class="router-list"><li class="nav-item"> <a href="/">主页</a></li><li class="nav-item"> <a href="/archives/">归档</a></li><li class="nav-item"> <a href="/atom.xml">RSS</a></li></ul><div class="mode-switch"><span class="iconfont icon-DarkTheme"></span></div></nav></header><main><section class="main-content"><section class="post-page"><div class="title-bar"><h1>算法与数据结构之栈(Stack)和队列(Queue)</h1><div class="post-info"><span>2024-01-08 11:49:53</span><span class="tags"><a href="/tags/%E7%AE%97%E6%B3%95/">#算法</a><a href="/tags/%E6%A0%88/">#栈</a><a href="/tags/%E9%98%9F%E5%88%97/">#队列</a></span></div></div><article> <div class="content"><h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><ol>
<li><strong>定义</strong>: 栈是一种遵循后进先出（LIFO, Last In First Out）原则的数据结构。这意味着最后添加到栈中的元素会是第一个被移除的。</li>
<li><strong>基本操作</strong>:<ul>
<li><strong>push</strong>: 向栈顶添加一个元素。</li>
<li><strong>pop</strong>: 移除并返回栈顶元素。</li>
<li><strong>peek&#x2F;top</strong>: 返回栈顶元素而不移除它。</li>
<li><strong>isEmpty</strong>: 检查栈是否为空。</li>
<li><strong>size</strong>: 返回栈中元素的数量。</li>
</ul>
</li>
<li><strong>应用</strong>:<ul>
<li>函数调用和递归。</li>
<li>撤销操作（如文本编辑器中的撤销）。</li>
<li>括号匹配等。</li>
</ul>
</li>
<li><strong>实现</strong>:<ul>
<li>可以使用数组或链表实现。</li>
<li>在数组实现中，栈的大小可能是固定的或动态扩展的。</li>
<li>在链表实现中，栈可以动态地增长，并且不存在大小的限制。</li>
</ul>
</li>
</ol>
<h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><ol>
<li><strong>定义</strong>: 队列是一种遵循先进先出（FIFO, First In First Out）原则的数据结构。这意味着最先添加到队列的元素会是第一个被移除的。</li>
<li><strong>基本操作</strong>:<ul>
<li><strong>enqueue</strong>: 在队列的尾部添加一个元素。</li>
<li><strong>dequeue</strong>: 移除并返回队列头部的元素。</li>
<li><strong>front</strong>: 返回队列头部的元素但不移除它。</li>
<li><strong>isEmpty</strong>: 检查队列是否为空。</li>
<li><strong>size</strong>: 返回队列中元素的数量。</li>
</ul>
</li>
<li><strong>应用</strong>:<ul>
<li>数据缓冲（如打印任务队列）。</li>
<li>任务调度。</li>
<li>在宽度优先搜索算法中使用。</li>
</ul>
</li>
<li><strong>实现</strong>:<ul>
<li>可以使用数组或链表实现。</li>
<li>链表实现更为常见，因为它可以轻松地在两端添加和删除元素。</li>
<li>在数组实现中，通常使用循环队列来避免空间浪费。</li>
</ul>
</li>
</ol>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul>
<li><strong>主要区别</strong>: 栈是LIFO，而队列是FIFO。</li>
<li><strong>使用场景</strong>: 栈通常用于解决涉及递归、回溯等问题，而队列适合于处理按顺序处理的任务。</li>
</ul>
<h3 id="在JS-x2F-Python-x2F-Go中的应用"><a href="#在JS-x2F-Python-x2F-Go中的应用" class="headerlink" title="在JS&#x2F;Python&#x2F;Go中的应用"></a><strong>在JS&#x2F;Python&#x2F;Go中的应用</strong></h3><ul>
<li><p><strong>JavaScript</strong>:</p>
<ul>
<li>栈可以用数组实现（使用 <strong><code>push</code></strong> 和 <strong><code>pop</code></strong> 方法）。</li>
<li>队列同样可以用数组实现（使用 <strong><code>push</code></strong> 和 <strong><code>shift</code></strong> 方法）。</li>
<li>示例代码<ul>
<li>栈(Stack)   <pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [];
    &#125;
    <span class="hljs-title function_">push</span>(<span class="hljs-params">element</span>) &#123;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(element);
    &#125;
    <span class="hljs-title function_">pop</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Underflow&quot;</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">pop</span>();
    &#125;
    <span class="hljs-title function_">peek</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];
    &#125;
    <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>;
    &#125;
&#125;

<span class="hljs-comment">// 使用栈</span>
<span class="hljs-keyword">let</span> stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();
stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">10</span>);
stack.<span class="hljs-title function_">push</span>(<span class="hljs-number">20</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-title function_">peek</span>()); <span class="hljs-comment">// 输出: 20</span>
stack.<span class="hljs-title function_">pop</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stack.<span class="hljs-title function_">peek</span>()); <span class="hljs-comment">// 输出: 10</span></code></pre></li>
<li>队列(Queue)  <pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = [];
    &#125;
    <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">element</span>) &#123;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(element);
    &#125;
    <span class="hljs-title function_">dequeue</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Underflow&quot;</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">shift</span>();
    &#125;
    <span class="hljs-title function_">front</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isEmpty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No elements in Queue&quot;</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-number">0</span>];
    &#125;
    <span class="hljs-title function_">isEmpty</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-title function_">size</span>(<span class="hljs-params"></span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>;
    &#125;
&#125;

<span class="hljs-comment">// 使用队列</span>
<span class="hljs-keyword">let</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>();
queue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-number">10</span>);
queue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-number">20</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue.<span class="hljs-title function_">front</span>()); <span class="hljs-comment">// 输出: 10</span>
queue.<span class="hljs-title function_">dequeue</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queue.<span class="hljs-title function_">front</span>()); <span class="hljs-comment">// 输出: 20</span></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Python</strong>:</p>
<ul>
<li>栈可以用列表实现（使用 <strong><code>append</code></strong> 和 <strong><code>pop</code></strong> 方法）。</li>
<li>队列可以用 <strong><code>collections.deque</code></strong> 实现，以支持高效的元素添加和删除。</li>
<li>示例代码<ul>
<li>栈(Stack) <pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.items = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">self, item</span>):
        <span class="hljs-variable language_">self</span>.items.append(item)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.is_empty():
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items.pop()
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Underflow&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">peek</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.is_empty():
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items[-<span class="hljs-number">1</span>]
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Empty Stack&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.items) == <span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">size</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.items)
<span class="hljs-comment"># 使用栈</span>
stack = Stack()
stack.push(<span class="hljs-number">10</span>)
stack.push(<span class="hljs-number">20</span>)
<span class="hljs-built_in">print</span>(stack.peek())  <span class="hljs-comment"># 输出: 20</span>
stack.pop()
<span class="hljs-built_in">print</span>(stack.peek())  <span class="hljs-comment"># 输出: 10</span></code></pre></li>
<li>队列(Queue)<pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable language_">self</span>.items = deque()

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">self, item</span>):
        <span class="hljs-variable language_">self</span>.items.append(item)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dequeue</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.is_empty():
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items.popleft()
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Underflow&quot;</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">front</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.is_empty():
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items[<span class="hljs-number">0</span>]
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Empty Queue&quot;</span>     

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_empty</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.items) == <span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">size</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.items)

<span class="hljs-comment"># 使用队列</span>
queue = Queue()
queue.enqueue(<span class="hljs-number">10</span>)
queue.enqueue(<span class="hljs-number">20</span>)
<span class="hljs-built_in">print</span>(queue.front())  <span class="hljs-comment"># 输出: 10</span>
queue.dequeue()
<span class="hljs-built_in">print</span>(queue.front())  <span class="hljs-comment"># 输出: 20</span></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Go</strong>:</p>
<ul>
<li>栈和队列通常需要自己实现，可以使用切片（slice）来实现栈，而队列则可以使用切片或链表实现。</li>
<li>示例代码<ul>
<li>栈(Stack)<pre><code class="hljs golang"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-keyword">type</span> Stack []<span class="hljs-type">int</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span></span> Push(v <span class="hljs-type">int</span>) &#123;
    *s = <span class="hljs-built_in">append</span>(*s, v)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Stack)</span></span> Pop() <span class="hljs-type">int</span> &#123;
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(*s) == <span class="hljs-number">0</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> <span class="hljs-comment">// 表示栈空</span>
    &#125;
    index := <span class="hljs-built_in">len</span>(*s) - <span class="hljs-number">1</span>
    element := (*s)[index]
    *s = (*s)[:index]
    <span class="hljs-keyword">return</span> element
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
    <span class="hljs-keyword">var</span> stack Stack
    stack.Push(<span class="hljs-number">10</span>)
    stack.Push(<span class="hljs-number">20</span>)
    fmt.Println(stack.Pop()) <span class="hljs-comment">// 输出: 20</span>
    fmt.Println(stack.Pop()) <span class="hljs-comment">// 输出: 10</span>
&#125;</code></pre></li>
<li>队列(Queue)<pre><code class="hljs golang"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-keyword">type</span> Queue []<span class="hljs-type">int</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Enqueue(v <span class="hljs-type">int</span>) &#123;
    *q = <span class="hljs-built_in">append</span>(*q, v)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Dequeue() <span class="hljs-type">int</span> &#123;
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(*q) == <span class="hljs-number">0</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> <span class="hljs-comment">// 表示队列空</span>
    &#125;
    element := (*q)[<span class="hljs-number">0</span>]
    *q = (*q)[<span class="hljs-number">1</span>:]
    <span class="hljs-keyword">return</span> element
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
    <span class="hljs-keyword">var</span> queue Queue
    queue.Enqueue(<span class="hljs-number">10</span>)
    queue.Enqueue(<span class="hljs-number">20</span>)
    fmt.Println(queue.Dequeue()) <span class="hljs-comment">// 输出: 10</span>
    fmt.Println(queue.Dequeue()) <span class="hljs-comment">// 输出: 20</span>
&#125;</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</div></article><div class="copyright-wrapper"><p>原文作者:<a href="https://duyu.page">Rick Lee</a></p><p>原文链接:<a href="https://duyu.page/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88(Stack)%E5%92%8C%E9%98%9F%E5%88%97(Queue)/">算法与数据结构之栈(Stack)和队列(Queue)</a></p><p>发表日期: 2024-01-08 11:49:53</p><p>更新日期: 2024-11-06 21:06:30</p><p>版权声明: 本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class="post-pager"><div class="prev"><a href="/%E5%A6%82%E4%BD%95%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" title="如何彻底搞懂深度优先搜索和广度优先搜索">上一篇 如何彻底搞懂深度优先搜索和广度优先搜索</a></div><div class="next"> <a href="/%E6%88%91%E7%AD%9B%E9%80%89%E5%87%BA%E4%BA%86%E8%AF%84%E5%88%86%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%81%E4%BD%8DCambly%E8%8B%B1%E8%AF%AD%E5%8F%A3%E8%AF%AD%E8%80%81%E5%B8%88/" title="我筛选出了评分最高的十位Cambly英语口语老师">下一篇 我筛选出了评分最高的十位Cambly英语口语老师</a></div></div><link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css"/><script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script><div id="gitalk-container"></div><script>new Gitalk({
  clientID: '2567ebe056a6a8828c51',
  clientSecret: '1503e9bf62441479908668610f3cfec314688f88',
  repo: 'techmovie.github.io',
  owner: 'techmovie',
  admin: 'techmovie',
  id: location.pathname.substr(0, 48),
  distractionFreeMode: true,
  labels: ['Gitalk'],
  title: '算法与数据结构之栈(Stack)和队列(Queue)',
}).render('gitalk-container');</script></section></section></main><footer class="footer-page"><div><span>Powered by</span><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a><span>| Theme</span><a target="_blank" rel="noopener" href="https://github.com/techmovie/hexo-theme-instapaper">instapaper</a></div></footer><script src="/scripts/dark.js"></script><script src="/scripts/post.js"></script></body></html>